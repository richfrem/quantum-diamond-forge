/**
 * Quantum Diamond Forge - Advanced Spec Validator
 * Version: 2.1
 * 
 * Purpose: Advanced validation of cross-artifact consistency with auto-fix capabilities.
 * Usage: node scripts/validator.js [options]
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// --- Configuration ---
const LOCKS_DIR = path.join(process.cwd(), 'docs/locks');
const LOCKFILES = {
    requirements: 'docs/locks/requirements.lock.json',
    architecture: 'docs/locks/architecture.lock.json',
    security: 'docs/locks/security.lock.json',
    testing: 'docs/locks/testing.lock.json',
    implementation: 'docs/locks/implementation.lock.json'
};

// --- Helper Functions ---

function readLockfile(name) {
    const filePath = path.join(process.cwd(), LOCKFILES[name]);
    if (!fs.existsSync(filePath)) {
        return null;
    }
    try {
        return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch (e) {
        console.error(`Error reading lockfile ${name}: ${e.message}`);
        return null;
    }
}

function loadAllLockfiles() {
    const locks = {};
    for (const name of Object.keys(LOCKFILES)) {
        locks[name] = readLockfile(name);
    }
    return locks;
}

// --- Validation Rules ---

function validateHashIntegrity(locks) {
    const results = { name: 'Hash Integrity Check', errors: [], warnings: [] };

    for (const [name, lockfile] of Object.entries(locks)) {
        if (!lockfile) {
            results.warnings.push(`Lockfile missing for: ${name}`);
            continue;
        }

        if (!fs.existsSync(lockfile.source)) {
            results.errors.push(`Source file missing for ${name}: ${lockfile.source}`);
            continue;
        }

        const content = fs.readFileSync(lockfile.source, 'utf8');
        const currentHash = crypto.createHash('sha256').update(content).digest('hex');

        if (currentHash !== lockfile.hash) {
            results.errors.push(`Hash mismatch for ${name}: source file has changed since lockfile was generated`);
        }
    }
    return results;
}

function validateApiDataModels(locks) {
    const results = { name: 'API ‚Üî Data Model Consistency', errors: [], warnings: [] };
    const archLock = locks.architecture;

    if (!archLock || !archLock.content) {
        // Warning already generated by integrity check if missing
        return results;
    }

    const { apis = [], dataModels = [] } = archLock.content;

    // Check 1: APIs referencing data models
    apis.forEach(api => {
        const match = api.match(/\/api\/([a-zA-Z0-9-]+)/);
        if (match) {
            const resource = match[1];
            const modelExists = dataModels.some(model => {
                const m = model.toLowerCase();
                const r = resource.toLowerCase();
                return m === r || m + 's' === r || m === r + 's';
            });

            if (!modelExists) {
                results.warnings.push(`Endpoint ${api} might be missing a data model for '${resource}'`);
            }
        }
    });

    // Check 2: Unused data models
    dataModels.forEach(model => {
        const isUsed = apis.some(api => api.toLowerCase().includes(model.toLowerCase()));
        if (!isUsed) {
            results.warnings.push(`Data model '${model}' appears unused in API endpoints`);
        }
    });

    return results;
}

function validateRequirementsTests(locks) {
    const results = { name: 'Requirements ‚Üî Tests Coverage', errors: [], warnings: [] };
    const reqLock = locks.requirements;
    const testLock = locks.testing;

    if (!reqLock || !reqLock.content) {
        return results;
    }

    const { features = [] } = reqLock.content;

    if (features.length > 0 && (!testLock || !testLock.content)) {
        results.warnings.push(`Found ${features.length} features but no testing lockfile/content.`);
    }

    return results;
}

// --- Reporting ---

function generateReport(results, format = 'text') {
    if (format === 'json') {
        console.log(JSON.stringify(results, null, 2));
        return;
    }

    console.log('\nüîç Quantum Diamond Forge - Spec Validation Report\n');

    let totalErrors = 0;
    let totalWarnings = 0;

    results.forEach(result => {
        if (result.errors.length === 0 && result.warnings.length === 0) {
            console.log(`‚úÖ ${result.name}`);
            return;
        }

        const icon = result.errors.length > 0 ? '‚ùå' : '‚ö†Ô∏è ';
        console.log(`${icon} ${result.name}`);

        result.errors.forEach(err => console.log(`   üî¥ ${err}`));
        result.warnings.forEach(warn => console.log(`   üî∏ ${warn}`));

        totalErrors += result.errors.length;
        totalWarnings += result.warnings.length;
        console.log('');
    });

    console.log('üìä Summary:');
    console.log(`   Errors: ${totalErrors}`);
    console.log(`   Warnings: ${totalWarnings}`);

    if (totalErrors > 0) {
        console.log('\n‚ùå Validation failed. Fix errors before proceeding.');
        process.exit(1);
    } else if (totalWarnings > 0) {
        console.log('\n‚ö†Ô∏è  Validation passed with warnings. Review before proceeding.');
    } else {
        console.log('\n‚úÖ All validations passed!');
    }
}

// --- Auto-Fix ---

function applyFixes(results) {
    console.log('\nüîß Attempting auto-fixes...');
    let fixedCount = 0;

    // Fix 1: Generate missing lockfiles
    const integrityResult = results.find(r => r.name === 'Hash Integrity Check');
    if (integrityResult) {
        integrityResult.warnings.forEach(warn => {
            if (warn.includes('Lockfile missing for:')) {
                const artifactName = warn.split(': ')[1];
                console.log(`   - Generating lockfile for ${artifactName}...`);
                try {
                    // We need to call the generator script
                    // Ideally we'd import the function, but for now let's spawn the process
                    const { execSync } = require('child_process');
                    execSync(`node scripts/generate_lockfile.js ${artifactName}`);
                    console.log(`     ‚úÖ Fixed: Generated ${artifactName}.lock.json`);
                    fixedCount++;
                } catch (e) {
                    console.log(`     ‚ùå Failed to generate lockfile: ${e.message}`);
                }
            }
        });
    }

    console.log(`\n‚ú® Applied ${fixedCount} fixes.`);
}

// --- Main ---

function main() {
    const args = process.argv.slice(2);
    const formatIndex = args.indexOf('--report');
    const format = formatIndex !== -1 ? args[formatIndex + 1] : 'text';
    const shouldFix = args.includes('--fix');

    // console.log('Loading lockfiles...'); // Quiet mode by default for JSON output
    const locks = loadAllLockfiles();

    const results = [];
    results.push(validateHashIntegrity(locks));
    results.push(validateApiDataModels(locks));
    results.push(validateRequirementsTests(locks));

    if (shouldFix) {
        applyFixes(results);
        // Re-run validation to show updated status? 
        // For now, just exit.
        return;
    }

    generateReport(results, format);
}

main();
