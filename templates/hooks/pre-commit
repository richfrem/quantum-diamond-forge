#!/usr/bin/env python3
"""
Pre-commit hook to prevent leaking secrets and enforce quality gates.
"""

import subprocess
import sys
import os
import re

# Configurable exclusions
EXCLUDED_DIRS = ["node_modules", "dist", "build", "coverage"]
EXCLUDED_PATTERNS = [
    ".githooks/*", "*.jpg", "*.jpeg", "*.png", "*.gif", "*.bmp", "*.tiff",
    "*.mp4", "*.avi", "*.mov", "*.webm", "*.mkv", "playwright-report/*",
    "package-lock.json", "yarn.lock", "pnpm-lock.yaml"
]

# Keys to scan for in assignments (case-insensitive regex with word boundaries)
SPECIFIC_API_KEYS = r"\b(?:GEMINI_API_KEY|OPENAI_API_KEY|RESEND_API_KEY|SUPABASE_SERVICE_ROLE_KEY|STRIPE_SECRET_KEY|VITE_GOOGLE_MAPS_API_KEY|VITE_SUPABASE_ANON_KEY)\b"
GENERIC_KEYS = r"\b(?:API_KEY|SECRET|TOKEN|PASSWORD)\b"
KEYS = f"(?:{SPECIFIC_API_KEYS}|{GENERIC_KEYS})"

# Whitelisted RHS patterns
WHITELIST_EXACT = ["<REDACTED>", "'<REDACTED>'"]
WHITELIST_PREFIXES = [
    "process.env.", "os.environ", "import.meta.env.",
    "${{ secrets.", "${{ vars.",
    "config.", "settings.", "env.",
    "getEnv(", "process.env.get(",
]
WHITELIST_CONTAINS = [
    "!!", "?.", "session?.", "auth.",
    "`", "import.meta", "process.env",
    "[", "]", "(", ")", "args[", "params.",
    "<", ">",
]

def is_whitelisted_rhs(rhs):
    if rhs in WHITELIST_EXACT: return True
    if any(rhs.startswith(prefix) for prefix in WHITELIST_PREFIXES): return True
    if any(pattern in rhs for pattern in WHITELIST_CONTAINS): return True
    if rhs.endswith(';'): return True
    return False

def is_variable_name(value):
    return bool(re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*$', value))

def get_staged_files():
    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "-z"],
            capture_output=True, check=True, text=False
        )
        output = result.stdout.decode('utf-8', errors='ignore')
        return [f for f in output.split('\0') if f.strip()]
    except subprocess.CalledProcessError:
        return []

def is_excluded(filepath):
    for excluded_dir in EXCLUDED_DIRS:
        if filepath.startswith(f"{excluded_dir}/"): return True
    for pattern in EXCLUDED_PATTERNS:
        regex_pattern = pattern.replace(".", r"\.").replace("*", ".*")
        if re.match(f"^{regex_pattern}$", filepath): return True
    return False

def extract_rhs_value(line):
    keys_pattern = r"\b(?:GEMINI_API_KEY|OPENAI_API_KEY|RESEND_API_KEY|SUPABASE_SERVICE_ROLE_KEY|STRIPE_SECRET_KEY|VITE_GOOGLE_MAPS_API_KEY|VITE_SUPABASE_ANON_KEY|API_KEY|SECRET|TOKEN|PASSWORD)\b"
    pattern = rf".*({keys_pattern})\s*[:=]\s*['\"]?([^'\"\s,]*)['\"]?"
    match = re.search(pattern, line, re.IGNORECASE)
    if match:
        rhs = match.group(2)
        rhs = rhs.rstrip(',;')
        return rhs
    return ""

def scan_file_for_secrets(filepath):
    violations = []
    try:
        result = subprocess.run(["git", "show", f":{filepath}"], capture_output=True, check=True, text=False)
        try:
            content = result.stdout.decode('utf-8')
        except UnicodeDecodeError:
            return violations
    except subprocess.CalledProcessError:
        return violations

    lines = content.splitlines(keepends=False)
    for lineno, line in enumerate(lines, 1):
        if re.search(KEYS, line, re.IGNORECASE):
            rhs = extract_rhs_value(line)
            if not rhs or is_whitelisted_rhs(rhs): continue
            
            is_specific_api_key = bool(re.search(SPECIFIC_API_KEYS, line, re.IGNORECASE))
            if not is_specific_api_key and is_variable_name(rhs): continue
            
            violations.append(f"VIOLATION: {filepath}:{lineno} -> {line.strip()}")
    return violations

def check_branch_protection():
    try:
        branch = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).decode('utf-8').strip()
        if branch in ["main", "master"]:
            return f"‚ùå Error: Direct commits to {branch} are not allowed. Please create a feature branch."
    except:
        pass
    return None

def run_drift_check():
    if os.path.exists("scripts/validate_drift.ts"):
        print("üîç Running Drift Check...")
        # Check if npx is available
        if subprocess.run(["command", "-v", "npx"], capture_output=True).returncode == 0:
            result = subprocess.run(["npx", "tsx", "scripts/validate_drift.ts"], capture_output=True)
            if result.returncode != 0:
                return "‚ùå Error: Drift Check Failed. Code does not match Blueprint."
    return None

def main():
    print("üõ°Ô∏è  Quantum Diamond Forge: Pre-commit Guard")
    
    # 1. Branch Protection
    branch_error = check_branch_protection()
    if branch_error:
        print(branch_error)
        sys.exit(1)

    # 2. Drift Check
    drift_error = run_drift_check()
    if drift_error:
        print(drift_error)
        sys.exit(1)

    # 3. Secret Scanning
    staged_files = get_staged_files()
    if not staged_files: sys.exit(0)

    exit_code = 0
    violations = []

    for filepath in staged_files:
        if not filepath or is_excluded(filepath): continue

        # Block .env files
        if filepath.endswith('.env') and filepath not in ['.env.example', 'dev_env.env', 'prod_env.env', 'test_env.env']:
            violations.append(f"BLOCKED .env file: {filepath}")
            exit_code = 1
            continue

        # Scan for secrets
        file_violations = scan_file_for_secrets(filepath)
        if file_violations:
            violations.extend(file_violations)
            exit_code = 1

    if exit_code != 0:
        print("‚ùå COMMIT BLOCKED: Violations found.")
        for violation in violations:
            print(violation)
        print("Fix by removing secrets or using '<REDACTED>'.")
        sys.exit(1)

    print("‚úÖ Pre-commit checks passed.")
    sys.exit(0)

if __name__ == "__main__":
    main()
